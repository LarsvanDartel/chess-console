use std::fmt::Write;

use super::types::*;
use super::tables::*;

pub const ZOBRIST_TABLE: [[u64; N_SQUARES]; N_PIECES] = [
    [793749156741385380, 17093822529494366854, 2870362809808521300, 3837651621553452677, 8185088700437107105, 973254195726959084, 10904857727237125166, 12582029403402413379, 1598871068214303888, 16435607607886916320, 14844207984361947174, 17793631618609425273, 7742504780229648037, 4486625289732091656, 6938763393987393675, 10466804422118632887, 14243409625626837530, 16773415116862878572, 5069339530466534130, 11829060872238091935, 12797126561883781683, 8975243454739227576, 5905908596139770804, 1748351320852427044, 8846712178922429726, 13272492941297365745, 9624153681785710429, 12184426051443448108, 2347282723221520581, 7056148758113263037, 2025297125292287530, 18247293099656924932, 15435088383736902269, 16646408193503317835, 12084115890553789209, 2914943367705701813, 4602463537789824497, 5981667986170091708, 207962513295697252, 11103677921833227794, 584398035089255657, 14397035746142903766, 2843801017073560540, 9151076938180259249, 14076681402904244366, 17462494955258594349, 14866682907184392812, 13966774961669049448, 4620689610017859589, 3514362430789882131, 7120769453656201504, 12359910011758080409, 5183204121040211230, 14662872701080479954, 1916039032468932541, 17242047230676830161, 6027773673788396218, 16276967061847467345, 2465482652798244170, 1254169601981302741, 10034045553852764743, 12701235636026371340, 7182009257501915666, 15341201688930718486],
    [10093912627133121710, 2346390733614811460, 14287912807684594578, 8891651234057451497, 9368304339487226575, 14783686895231038741, 496308621401728371, 5762084431293015462, 16016233997075586539, 1167693118186895706, 16012603719358940843, 737695594005578606, 10724106862219249684, 11970642555146297744, 18247505183333755789, 4617848617242968132, 6760588420853412471, 970345668152661325, 12093760185217805650, 15187954858493348286, 662238677280823100, 8954753491681740319, 3727077927145858796, 9073924343472011769, 11214278926273663897, 4984371255998194518, 8742928802078354957, 7572749400695327470, 16543746303649222840, 3495102364894280263, 6040449582062232462, 3487654410990695611, 12610888628555478837, 10293382266934703214, 15840549386086163667, 6438267687840101530, 6431482912840674925, 120601478522084950, 1108680966663983083, 16619440270497758629, 8855846374794231754, 1352950876555655305, 7093050852200704302, 17611815991223518842, 903961453614663190, 16535968984240749882, 1641360920867776960, 16147892071652829997, 11376762553220966082, 6104355214198593122, 11564528896150207313, 14885051898759175101, 7970408255702639729, 2435603524069120824, 16498746626731023684, 13069115322159176655, 11130477213451546598, 1450674247268381219, 3171159921146657283, 3941536212953870695, 12164099264676441221, 6503451138042326737, 8620368068229976091, 10956715378052344707],
    [16272767762553903256, 14996603729269398181, 14212476263040215320, 12936234917262132274, 17681334281003270935, 16654249719687730605, 15569610878879607876, 16533590837106109858, 5911178027334966316, 2894698923322163546, 6537384023335837906, 5589160641325918820, 4935068260399428501, 1753303917257067078, 7462843671497389838, 12435783721119138522, 10843468448831113605, 10489861870251026386, 10010037687783673316, 1888219614997607485, 4649968994388542256, 13802512036156328590, 2928535301810030395, 7769638582735555199, 1652605790487103842, 5874930179347951490, 16809751011443464618, 5196409092546829004, 687389587838742698, 5087259446440683929, 6669967247190081859, 3585417876446994237, 15947822810610149401, 15721119772084736135, 12080054706606382121, 11222633758378474918, 16083179911370394506, 9788986325068395769, 6420006666880405161, 14751719528974863617, 5492694976272928490, 6358015460939289244, 2546922797446595213, 4244738754821005460, 5127459899628251092, 8839507908886532705, 18443633350790572446, 8631356926542050229, 2071304286909704502, 12257137038005429476, 2628881197491680146, 4302281996223288678, 3465155445693920258, 3031839078437451602, 17145605857795698545, 10903028619216374902, 4809784944885166635, 10852717086396195976, 14779545011605035671, 9275377330880154592, 18293750385267195903, 7778536068808454942, 9980853522185057605, 17412097680677341569],
    [407030176477895669, 8156101071676727545, 17430284943031468288, 3553405545259921802, 13275525199398705589, 7738435850993831422, 4955297991045338184, 2008455698755430808, 2326186212665655111, 4220965157154804580, 13441422139234811532, 1265253696887754869, 5730168790520676858, 16036400355766753485, 8264430722878173577, 15458759569563661031, 4217318621349793938, 14566568074673688857, 13218102192965169720, 12663186961926648028, 15904922643408358857, 15021790178757506429, 3294976128779047824, 13693914499348704576, 6069889087110893622, 5471176979279769285, 812125924533057028, 14759162027538062895, 1310017338978985580, 1044624007791809055, 18237039889313804126, 16957362239711103269, 18180151904567809674, 11415693605497564054, 4377769504948653695, 10850095601936033821, 11726745507013311108, 1914787659637852673, 14346025310738182509, 16593463348616360316, 5984009365070811954, 15165083029764114355, 18104140824959125966, 13026396149227423608, 3654744175683228011, 18103051722350438179, 4791961412899475007, 16405395726451399848, 1719651835641863460, 5043160200575041312, 5728438755710328473, 15147925873690611524, 7711952682364449671, 8457832891232789234, 16026964227534912722, 4407703447122353746, 9826218930647885453, 15251449534634822061, 14683882741526136025, 5013913540873232283, 12689793406577465717, 414747549496067552, 6651791952617939624, 10185597240197068098],
    [16117126124745915350, 4833568484236289348, 1894774027628002607, 14087195975003723535, 9887742508768906893, 14825186920531467447, 11569706270693543653, 15491076876238267611, 15819260488365403766, 2706350419998072399, 6247061301080030513, 11990517664158832337, 7764747450894219457, 14179303636422824074, 9516554606239669234, 12191732805719335226, 12329032271240891729, 927464790196363208, 7653539004322544374, 613607226144021437, 18253638002885085110, 6072766242051867179, 9540647755883202712, 10809442781281046417, 7238479329367223921, 3618054698315668245, 15841593395532570188, 3747284153804548480, 7832091237345854587, 11826547461657670406, 14459609160563656506, 11108802460293917764, 14448875116591269013, 15417965572142383657, 10726361881631689878, 1073764807934634069, 8156542429964407991, 14076464707100230153, 11311276003223041913, 13379603129023033840, 16856307193661071132, 13972313662292661543, 12953047373921966477, 283665465870729309, 10493485877409846221, 2206186947980585765, 4149566468454823334, 8364714295280238991, 8115269247133658258, 6594192688289433419, 10216353758397936133, 6306020930896515729, 2506436660315072526, 6075517892123987254, 1977292277245909205, 3560316424599322931, 9999010951519542706, 220323621729842436, 17913671909176674810, 14806706662712416966, 17095678947313885951, 4105462116841970749, 16642910294456622317, 5841966362227228193],
    [14257762368158240198, 8347560402761145475, 3416977144588667149, 5113856447089785462, 16094152509505684251, 13548132449393069384, 12731005751627434551, 16883691370557974483, 8309137139593335009, 13837113239582349485, 8338784338217038790, 6297779202188640829, 13907818315006617810, 6640876577422525112, 7573203296540329741, 12826879632823005993, 6937910004671713353, 12313229165956187211, 10058835748154504281, 1119216999495662475, 15726174283664363407, 2541826408918823279, 17912149924910717257, 14953217275814457471, 11557881094355521391, 9117261502225320444, 5667158399535430596, 1263895997869785786, 13992600329154236000, 10681470548926022279, 10050384407022448267, 9250050097887794662, 17483750254069420671, 14026139549746834831, 14785786961800088046, 8766700759742841294, 17499189673224241852, 3644216099289637234, 18052782574660679944, 14206486822683830639, 15178571836036561016, 17279392101497284945, 11838110835462052606, 4343210424477538641, 9883973643646743271, 2405526588472364765, 6337700690848558390, 572509947648040230, 3025805402329979993, 11651980534527776611, 7873028440300221350, 8592705582223248740, 6816500660165263799, 5657456629253025551, 9425557578230916057, 11864787735030270037, 10893764768319175914, 714356388654335726, 1405932251878091286, 6806160448760213465, 3009935705609073658, 6843906453819146927, 7835803547078932501, 11107564110127280388],
    [686201492179460485, 8790704366154688465, 11366443428032869503, 10485626919140983876, 13537911437469130652, 5422191416076119064, 15164132246909112024, 16081635099916959664, 12459255767675716663, 9839336276684425122, 13016385476620641575, 14660513914544950993, 9303014608318222356, 9002848129957470412, 14485576926141679571, 16015270049379134675, 16722890341274935376, 3117380103671914763, 16665773911345424861, 7928489440219174364, 10024373257092726922, 6202266575711250578, 6280963121097372118, 9219027938754734516, 14877587246346050407, 12795074637537233057, 5727658744941698854, 8929347064911712847, 12418313161029402566, 14160816736023365691, 243170458812011253, 15321068013096036557, 11105710505544346601, 9601095777956645323, 10240364639730191387, 11121122738054862246, 2217723354945930134, 15581571617399998015, 15244444894607664587, 3282741740925329178, 12610143150920203309, 12956277974480345724, 7564678447228991570, 6781888558703783557, 16622888680190797079, 11553911817756001872, 6990571350153060868, 13611931187057612171, 4700755222080703730, 16937470107868858461, 13488037434537675331, 4127868121178973690, 6692717302666244996, 2242555440429626367, 5844465864012517217, 3158343247504934438, 6539319452015872243, 12489500595472266134, 4667480226066945584, 1289325053775154496, 17113252480823832353, 17038631893880854181, 16522934967553534607, 16200909172784229427],
    [8110963366781847258, 2751441231477465130, 11923569687181466681, 17381637657842515735, 13922801758752441888, 15653673651364136502, 11404263838236264977, 1815464620006183352, 9617156083997463518, 3405845728385034974, 11882283271738342333, 17198063071333358959, 10923029988370869938, 12569835173813473266, 307721079957479961, 13658465297087407512, 10910970465879771633, 11840773743742305331, 2280441553643383344, 1589035758463322464, 8728201257882288761, 1309428426495220395, 10745392564749378533, 5972223231412909450, 1555302293349044410, 16242383049020098885, 5748036508615674988, 3295328298933884135, 5150871027590859305, 10100021252164788667, 857836966635354407, 7851122530020239339, 1814024515644337041, 18416791486453852692, 7798659868871333627, 17858315367678757450, 5027397287731694053, 7029301512945939029, 7037835731199859149, 1609470533246068644, 9896699659083122495, 9060504121515426263, 1871632595902995097, 14661774706779380219, 13079126742332998548, 10048853448850197786, 16701198366530154464, 6253122563888000346, 1194333275438357059, 12004845267990463804, 4387867781457697364, 11613192471834005702, 16661567849650521749, 11027350469531770321, 8612961640098093825, 8445220666566659556, 3340774664864600682, 5190805983328684809, 15397649358586688893, 3237802640892538906, 11638897145546478633, 12702962426847087813, 5316717901529348704, 17285671865200784285],
    [8974888913256252044, 15168067625461284208, 7631661995099546578, 16024190748425774845, 16887284033758999379, 16745884438096157679, 3851924575871845600, 17493806636703890121, 3953620512321594476, 6580222881243463946, 17965976006204951931, 18443186449186114745, 11737504323166796075, 7468239890610810739, 1933290044056935284, 11619878200373119974, 17171548327061889074, 12508417852982596021, 9657205908500136128, 5736947198056747878, 4920994210904014617, 16901524718249081332, 1520161014348191331, 10298559980481687477, 1634357629271346849, 9394614672654744284, 5624351431786820174, 17169832080929627188, 18095332261113643522, 5742123550884049949, 3249887039919466062, 5221187847649953441, 9207930560633036309, 1693743591157703530, 2995637698043681959, 6402181546705670198, 4541563079856514575, 11068422090392629177, 9494082560553690965, 2852428024880266, 587509466942460833, 1043911941588400645, 3897506760954195258, 16019465610582454401, 7480377315023917075, 6085858238948893385, 10697354941359760628, 6014292579021069400, 2012238116860254215, 10882631562768432577, 11644457361166597692, 3949498498886519089, 17738500780423745464, 1903302169194954046, 13612228691250233597, 16147933890744400073, 1097924824087925434, 12234517047896414551, 17034751776518203080, 12713310707644095276, 14826860892317987919, 11486382073616346471, 6264957981675837640, 13763295561417574295],
    [17623734240550065178, 13641944943625236837, 6518558256756169466, 3390515298402955603, 18035072296863878648, 10643097944079451368, 5011946005307594718, 2548156589736039419, 13437278355192416195, 1634440034282734526, 2740377765447057050, 10901527725962082633, 5147240202007442856, 5345172405235492793, 12663160660471215467, 7335797318571659033, 1113932050313852808, 15645936550610360433, 1582431746710941035, 5148628508219301547, 468739220349472235, 9292073336622484259, 4950058505275220776, 339631727463495792, 14328682968397412490, 429322931642978386, 4937140206626832431, 1560785302072939330, 1595297983096483203, 16752989042929006275, 1696600103820942841, 16247855718478879127, 15089925144515426893, 18306615882298101470, 6355172479445825953, 13457243194254567790, 9282488969377422943, 6012857112877256917, 5188085312028582171, 12105558946603908717, 3628618562694022689, 14576028685148671966, 308677038240388962, 17264260722215626538, 18382041064867231094, 12660367217487057922, 11027785098790365951, 8049346358050523016, 1139384127074241237, 8351361539552465346, 12872472125109541410, 598317351166607196, 18283406626437033774, 14160000370284618186, 17583735973476128282, 6143511830311737688, 5590489966654438452, 8741514348760729036, 10970761730907554279, 17113636230241276875, 6574248518424074359, 7186674562275583379, 3840454272853516296, 5199666114745209749],
    [10233087664910420019, 12790157513399223526, 13829820411894799341, 17902656542864248518, 1515170063165122987, 14320198151564489136, 14264118240479393184, 15373478268078616025, 4283634899471799716, 8794496403387818440, 8709900818753849779, 17887835968073077086, 15458542250113709152, 16207328655181589343, 5343623114981090718, 5294504869604689212, 9756934789065911673, 530432127823845756, 16715954284404322317, 4581211036273748291, 7955351260389398619, 16941345620191045188, 2045511185429814571, 17155817936234017281, 972723534389475579, 5032185024833293949, 4462347516176115137, 12524887976466909877, 17246341468534914642, 18025460310856305797, 9788840898504405570, 17062087226447418615, 12312066787930920453, 9264046325837059937, 10320161206331668254, 10556715711998363074, 11087260062382980237, 11015423393282376473, 11343206506084609261, 8830232669234099838, 2113057049254196647, 14968786027394913347, 10940061402999194548, 7775172166488499313, 11944664369648892200, 6156141923040352090, 9944351014172899878, 7370506993773498946, 14915060616612087860, 10653135576654714498, 8287762841448896628, 16482568703559949193, 18020106315202037174, 2913907589707917381, 17969418689381915354, 15292752679328453016, 4510076976530285837, 9956934636987286591, 2937904173558109177, 5144134996865527047, 18346093276397499731, 14881439552231034705, 5737425100662469073, 1689379595059933139],
    [2823484439555965767, 9768790530296086956, 14799242165008865381, 17095323202489335570, 10143438325148865088, 16817484933526024373, 17210518546691104238, 5299824356327912797, 8071192546011908184, 16233036157976942461, 15645235093430584850, 4079284405533329237, 7874346106944641196, 4945993246665328384, 9549186978018140115, 9985573165948786828, 13494840789307060588, 6552500377840454464, 10654234302262190493, 6247091128404614574, 14563487000348035778, 7359963009130969921, 4037369367105028365, 3641943820024561512, 12224571154673660920, 16123836571220025336, 5309101493864580380, 11143631381166198675, 13474981824102000014, 9473588082940156970, 2918393610878866256, 13887970059599673307, 15533866634057762109, 2213811313158729855, 13576351364552210094, 8794827688209881085, 8202426068987420193, 9057987639889377853, 6978848808330285503, 10454911180911550881, 8855575340163897075, 6615310034131387886, 11784828848120520963, 735270098519738272, 14707962909293935486, 17737610182125184571, 12145746443398402094, 12961487414031303540, 11703004472054041085, 10105242935181406203, 12060793945825062283, 15054504332321730650, 8626050312818940028, 5805625579619014614, 3982556712941561166, 11846862313482888843, 12336252658320138426, 10714452560160349359, 10719623620220795185, 14442207279709385873, 2311875299999893661, 14005435416363363904, 930704416116206059, 15675069416823059800],
    [5044254272652948280, 16287875401722341929, 9880993739167914014, 8775758023457250723, 3476532209911384430, 5416596205688680080, 4992972116152898430, 7785693645922208623, 4769705134346273176, 18107556563538680218, 5731031181497437968, 595616161532651584, 10865295466304341681, 8490193194735296999, 5064370953942234575, 1540276568489422701, 121260237630723151, 12079527741620913660, 14015704050902990609, 14827897552305606682, 5108799688904865269, 8374967456096554535, 8184570716680452136, 6972552743340054648, 11968760365746352190, 13726004932228929629, 5653021685577005581, 6239672022216488443, 11608450875415662980, 3973778829974836378, 8898776329461768711, 9858920063007439254, 9078653488020295531, 9326194413613621987, 15606129769210814415, 12463940683324824136, 6345510201247807883, 2156374705083773155, 2984680553625482698, 16974811161573983128, 13341275629918151371, 10971580785051341520, 636324483571057379, 14003101099744893087, 15899210954042920307, 17294901494390902698, 11250981581144881493, 15651724997962555241, 5075499213202624213, 6038637645909973429, 15787649517309082734, 13518128463680202943, 15857521929754419278, 240943304353552347, 17642769613821674533, 7852454680029986050, 4311274218028134475, 16764822469951165956, 12324181457037928500, 15616284141816451784, 6360887577664402200, 4405809874640551619, 10988189679957574444, 5506461714922987443],
    [3119320645143303805, 10875866646474898131, 18356903873663535580, 12312686610566369827, 16345769782861440788, 4924801042121370620, 2046077628355772964, 4514341859880043639, 279493442607517953, 17003351076126008476, 7288086328797891548, 11101395828003507591, 3235391777069763317, 4410362235919565046, 6913636452305014550, 17735207925911281742, 4924293473501597106, 1062282546908100926, 794825853367438628, 6040008606598506671, 5745739492129041770, 16659275476322415279, 5677122677340097320, 14560343386443998033, 13358102982487559859, 16786995728348222638, 859776577339917041, 3278319160105386165, 16488938851046241946, 14130165038111321538, 14510148858774758928, 13416603809651004699, 17748446255703676227, 15214673364973520644, 14126871855732202725, 1840713031209666306, 11223424235275703327, 14943813116527007469, 4973780402832516785, 8843816653507843336, 2292888949899541645, 1834675105208244036, 4302802575166288185, 1659857751432712311, 10935369504478937815, 3091815466795457242, 7768343501319699277, 17501415144242866195, 4094919588593259770, 13864808101176305789, 10724609561299945645, 3817664631981823226, 5425945341497090588, 18306895259970236704, 2007021391773422477, 9458010502582292367, 1951058622459705164, 15291049234818500320, 1545370726066886330, 9925718008180226599, 16273150360444343260, 1636513055399587304, 4403065885092112526, 13596742853088010216],
    [12998509211815381115, 9641465757381236614, 2446398210072749523, 10461160915921992747, 12937708642869865228, 10830511793297298550, 4499152991999400774, 13195219793605122437, 12592747496848638304, 17790656912742999896, 16877164202499735611, 935464937639613669, 5799661169326169668, 12724344811104054066, 17337151452638349400, 13256356425524732019, 15388445556516667143, 647191279890149575, 6451470184184912473, 14478886919462508036, 8697487303712386254, 15283108395856486147, 8741742321119285225, 12398957236111418578, 1234231955291382127, 18262489110026898699, 1415347999109019972, 15340988780669059558, 1053036121627976831, 365182204239158818, 700765562915062819, 12902597201891003447, 6939977018518789170, 16630774898380328222, 3595996692038192192, 7434441584269696502, 6761057836059575021, 11764609689650194138, 13238412159116419024, 18313227162962140450, 16519512774453118585, 5343530776382001831, 6573606101421570337, 2094339890414330656, 16844312313178083096, 10790226791779538910, 9184646578001625574, 7474256605877899607, 203094356206472722, 10232315106995298825, 16817378377190226067, 5901867572290933071, 5269486451522486084, 14440734795122205434, 1109772825168490627, 894656038745915815, 14518873372589897869, 15749883122239356767, 14564823808977601629, 2077931214386047688, 11896833500636024034, 16764660839740825941, 7531587486981909772, 1611098215490047011]
];

pub struct UndoInfo {
    pub entry: Bitboard,
    pub captured: Piece,
    pub epsq: Square,
    pub halfmove_clock: usize,
    pub hash: u64,
    pub m: Move,
}

impl UndoInfo {
    pub const fn new() -> Self {
        UndoInfo { entry: 0, captured: PIECE_NONE, epsq: SQUARE_NONE, halfmove_clock: 0, hash: 0, m: 0 }
    }

    pub const fn next(prev: &Self) -> Self {
        UndoInfo { entry: prev.entry, captured: PIECE_NONE, epsq: SQUARE_NONE, halfmove_clock: 0, hash: 0, m: 0 }
    }
}

#[derive(Clone, Copy)]
pub enum GameResult {
    Checkmate(Color),
    Stalemate,
    FiftyMoveRule,
    ThreefoldRepetition,
    InsufficientMaterial,
}

/// The FEN of the starting position
pub const STARTING_FEN: &str = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

/// The Kiwipete position, used for perft debugging
pub const KIWIPETE: &str = "r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 1";

pub struct Position {
    pub piece_bb: [Bitboard; N_PIECES],
    pub board: [Piece; N_SQUARES],
    pub turn: Color,
    pub game_ply: usize,
    pub halfmove_clock: usize,
    pub fullmove_number: usize,
    pub hash: u64,
    pub history: [UndoInfo; 1024],
    pub checkers: Bitboard,
    pub in_check: bool,
    pub pinned: Bitboard,
    pub result: Option<GameResult>
}

impl Position {
    pub fn new() -> Self {
        const UNDO: UndoInfo = UndoInfo::new();
        Position {
            piece_bb: [0; N_PIECES],
            board: [PIECE_NONE; N_SQUARES],
            turn: WHITE,
            game_ply: 0,
            halfmove_clock: 0,
            fullmove_number: 0,
            hash: 0,
            history: [UNDO; 1024],
            checkers: 0,
            in_check: false,
            pinned: 0,
            result: None,
        }
    }

    pub fn put_piece(&mut self, p: Piece, sq: Square) {
        self.board[sq as usize] = p;
        self.piece_bb[p as usize] |= SQUARE_BB[sq as usize];
        self.hash ^= ZOBRIST_TABLE[p as usize][sq as usize];
    }

    pub fn remove_piece(&mut self, sq: Square) {
        self.hash ^= ZOBRIST_TABLE[self.board[sq as usize] as usize][sq as usize];
        self.piece_bb[self.board[sq as usize] as usize] &= !SQUARE_BB[sq as usize];
        self.board[sq as usize] = PIECE_NONE;
    }

    pub fn move_piece(&mut self, from: Square, to: Square) {
        self.hash ^= ZOBRIST_TABLE[self.board[from as usize] as usize][from as usize] ^
                     ZOBRIST_TABLE[self.board[from as usize] as usize][to as usize] ^
                     ZOBRIST_TABLE[self.board[to as usize] as usize][to as usize];

        let mask: Bitboard = SQUARE_BB[from as usize] | SQUARE_BB[to as usize];
        self.piece_bb[self.board[from as usize] as usize] ^= mask;
        self.piece_bb[self.board[to as usize] as usize] &= !mask;

        self.board[to as usize] = self.board[from as usize];
        self.board[from as usize] = PIECE_NONE;
    }

    pub fn move_piece_quiet(&mut self, from: Square, to: Square) {
        self.hash ^= ZOBRIST_TABLE[self.board[from as usize] as usize][from as usize] ^
                     ZOBRIST_TABLE[self.board[from as usize] as usize][to as usize];

        self.piece_bb[self.board[from as usize] as usize] ^= SQUARE_BB[from as usize] | SQUARE_BB[to as usize];

        self.board[to as usize] = self.board[from as usize];
        self.board[from as usize] = PIECE_NONE;
    }

    pub fn load_fen(&mut self, fen: &str) -> Result<(), String> {
        let mut fen = fen.split(' ');

        let board = fen.next().ok_or("Missing board")?;
        let mut sq: Dir = A8 as Dir;

        for c in board.chars() {
            if c.is_ascii_digit() {
                sq += (c as u8 - b'0') as Dir * EAST;
            } else if c == '/' {
                sq += 2 * SOUTH;
            } else {
                self.put_piece(piece_from(c), sq as Square);
                sq += EAST;
            }
        }

        self.turn = match fen.next().ok_or("Missing turn")? {
            "w" => WHITE,
            "b" => BLACK,
            _ => return Err("Invalid turn".to_string()),
        };

        let castling = fen.next().ok_or("Missing castling")?;

        self.history[self.game_ply].entry = ALL_CASTLING_MASK;

        for c in castling.chars() {
            match c {
                'K' => self.history[self.game_ply].entry &= !WHITE_OO_MASK,
                'Q' => self.history[self.game_ply].entry &= !WHITE_OOO_MASK,
                'k' => self.history[self.game_ply].entry &= !BLACK_OO_MASK,
                'q' => self.history[self.game_ply].entry &= !BLACK_OOO_MASK,
                _ => {}
            }
        }

        self.history[self.game_ply].epsq = match fen.next().ok_or("Missing en passant")? {
            "-" => SQUARE_NONE,
            sq => square_from_str(sq)?
        };

        self.halfmove_clock = fen.next().ok_or("Missing halfmove clock")?.parse::<usize>().map_err(|_| "Invalid halfmove clock")?;
        self.fullmove_number = fen.next().ok_or("Missing fullmove number")?.parse::<usize>().map_err(|_| "Invalid fullmove number")?;

        Ok(())
    }

    pub fn fen(&self) -> String {
        let mut fen = String::new();

        let mut empty_sqs: u8;

        for i in (0..8).rev() {
            empty_sqs = 0;
            for j in 0..8 {
                let p = self.board[i * 8 + j];
                if p == PIECE_NONE { empty_sqs += 1; }
                else {
                    if empty_sqs != 0 { write!(fen, "{}", empty_sqs).unwrap(); }
                    write!(fen, "{}", PIECE_STR[p as usize]).unwrap();
                    empty_sqs = 0;
                }
            }
            if empty_sqs != 0 { write!(fen, "{}", empty_sqs).unwrap(); }
            if i > 0 { write!(fen, "/").unwrap(); }
        }

        write!(fen, " {} ", if self.turn == WHITE { 'w' } else { 'b' }).unwrap();
        if self.history[self.game_ply].entry & WHITE_OO_MASK == 0 { write!(fen, "K").unwrap(); }
        if self.history[self.game_ply].entry & WHITE_OOO_MASK == 0 { write!(fen, "Q").unwrap(); }
        if self.history[self.game_ply].entry & BLACK_OO_MASK == 0 { write!(fen, "k").unwrap(); }
        if self.history[self.game_ply].entry & BLACK_OOO_MASK == 0 { write!(fen, "q").unwrap(); }
        if self.history[self.game_ply].entry & ALL_CASTLING_MASK != 0 { write!(fen, "-").unwrap(); }
        write!(fen, " {} ", if self.history[self.game_ply].epsq == SQUARE_NONE { "-" } else {
            SQUARE_STR[self.history[self.game_ply].epsq as usize]
        }).unwrap();

        write!(fen, "{} ", self.halfmove_clock).unwrap();
        write!(fen, "{}", self.fullmove_number).unwrap();

        fen
    }

    pub const fn bb_of(&self, c: Color, pt: PieceType) -> Bitboard {
        self.piece_bb[create_piece(c, pt) as usize]
    }

    pub const fn diagonal_pieces<const COLOR: Color>(&self) -> Bitboard {
        if COLOR == WHITE {
            self.piece_bb[WHITE_BISHOP as usize] | self.piece_bb[WHITE_QUEEN as usize]
        } else {
            self.piece_bb[BLACK_BISHOP as usize] | self.piece_bb[BLACK_QUEEN as usize]
        }
    }

    pub const fn orthogonal_pieces<const COLOR: Color>(&self) -> Bitboard {
        if COLOR == WHITE {
            self.piece_bb[WHITE_ROOK as usize] | self.piece_bb[WHITE_QUEEN as usize]
        } else {
            self.piece_bb[BLACK_ROOK as usize] | self.piece_bb[BLACK_QUEEN as usize]
        }
    }

    pub const fn all_pieces<const COLOR: Color>(&self) -> Bitboard {
        if COLOR == WHITE {
            self.piece_bb[WHITE_KING as usize] | self.piece_bb[WHITE_QUEEN as usize] |
            self.piece_bb[WHITE_ROOK as usize] | self.piece_bb[WHITE_BISHOP as usize] |
            self.piece_bb[WHITE_KNIGHT as usize] | self.piece_bb[WHITE_PAWN as usize]
        } else {
            self.piece_bb[BLACK_KING as usize] | self.piece_bb[BLACK_QUEEN as usize] |
            self.piece_bb[BLACK_ROOK as usize] | self.piece_bb[BLACK_BISHOP as usize] |
            self.piece_bb[BLACK_KNIGHT as usize] | self.piece_bb[BLACK_PAWN as usize]
        }
    }

    pub const fn attackers_from<const COLOR: Color>(&self, sq: Square, occ: Bitboard) -> Bitboard {
        if COLOR == WHITE {
            pawn_attacks::<BLACK>(sq) & self.piece_bb[WHITE_PAWN as usize] |
            attacks::<KNIGHT>(sq, occ) & self.piece_bb[WHITE_KNIGHT as usize] |
            attacks::<BISHOP>(sq, occ) & (self.piece_bb[WHITE_BISHOP as usize] | self.piece_bb[WHITE_QUEEN as usize]) |
            attacks::<ROOK>(sq, occ) & (self.piece_bb[WHITE_ROOK as usize] | self.piece_bb[WHITE_QUEEN as usize])
        } else {
            pawn_attacks::<WHITE>(sq) & self.piece_bb[BLACK_PAWN as usize] |
            attacks::<KNIGHT>(sq, occ) & self.piece_bb[BLACK_KNIGHT as usize] |
            attacks::<BISHOP>(sq, occ) & (self.piece_bb[BLACK_BISHOP as usize] | self.piece_bb[BLACK_QUEEN as usize]) |
            attacks::<ROOK>(sq, occ) & (self.piece_bb[BLACK_ROOK as usize] | self.piece_bb[BLACK_QUEEN as usize])
        }
    }

    pub fn make_move<const COLOR: Color>(&mut self, m: Move) {
        self.turn = self.turn ^ 1;
        self.history[self.game_ply].m = m;
        self.game_ply += 1;
        self.halfmove_clock += 1;
        if COLOR == BLACK { self.fullmove_number += 1; }
        self.history[self.game_ply] = UndoInfo::next(&self.history[self.game_ply - 1]);
        let flags: MoveFlags = get_flags(m);
        self.history[self.game_ply].entry |= SQUARE_BB[get_to(m) as usize] | SQUARE_BB[get_from(m) as usize];

        match flags {
            QUIET => {
                if piece_type_of(self.board[get_from(m) as usize]) == PAWN {
                    self.halfmove_clock = 0;
                }
                self.move_piece_quiet(get_from(m), get_to(m));
            },
            DOUBLE_PUSH => {
                self.halfmove_clock = 0;
                self.move_piece_quiet(get_from(m), get_to(m));

                self.history[self.game_ply].epsq = (get_from(m) as Dir + relative_dir::<COLOR>(NORTH)) as Square
            },
            OO => {
                if COLOR == WHITE {
                    self.move_piece_quiet(E1, G1);
                    self.move_piece_quiet(H1, F1);
                } else {
                    self.move_piece_quiet(E8, G8);
                    self.move_piece_quiet(H8, F8);
                }
            },
            OOO => {
                if COLOR == WHITE {
                    self.move_piece_quiet(E1, C1);
                    self.move_piece_quiet(A1, D1);
                } else {
                    self.move_piece_quiet(E8, C8);
                    self.move_piece_quiet(A8, D8);
                }
            },
            EN_PASSANT => {
                self.move_piece_quiet(get_from(m), get_to(m));
                self.remove_piece((get_to(m) as Dir + relative_dir::<COLOR>(SOUTH)) as Square);
            },
            PQ_QUEEN => {
                self.remove_piece(get_from(m));
                self.put_piece(create_piece(COLOR, QUEEN), get_to(m));
            },
            PQ_ROOK => {
                self.remove_piece(get_from(m));
                self.put_piece(create_piece(COLOR, ROOK), get_to(m));
            },
            PQ_BISHOP => {
                self.remove_piece(get_from(m));
                self.put_piece(create_piece(COLOR, BISHOP), get_to(m));
            },
            PQ_KNIGHT => {
                self.remove_piece(get_from(m));
                self.put_piece(create_piece(COLOR, KNIGHT), get_to(m));
            },
            PC_QUEEN => {
                self.halfmove_clock = 0;
                self.remove_piece(get_from(m));
                self.history[self.game_ply].captured = self.board[get_to(m) as usize];
                self.remove_piece(get_to(m));
                self.put_piece(create_piece(COLOR, QUEEN), get_to(m));
            },
            PC_ROOK => {
                self.halfmove_clock = 0;
                self.remove_piece(get_from(m));
                self.history[self.game_ply].captured = self.board[get_to(m) as usize];
                self.remove_piece(get_to(m));
                self.put_piece(create_piece(COLOR, ROOK), get_to(m));
            },
            PC_BISHOP => {
                self.halfmove_clock = 0;
                self.remove_piece(get_from(m));
                self.history[self.game_ply].captured = self.board[get_to(m) as usize];
                self.remove_piece(get_to(m));
                self.put_piece(create_piece(COLOR, BISHOP), get_to(m));
            },
            PC_KNIGHT => {
                self.halfmove_clock = 0;
                self.remove_piece(get_from(m));
                self.history[self.game_ply].captured = self.board[get_to(m) as usize];
                self.remove_piece(get_to(m));
                self.put_piece(create_piece(COLOR, KNIGHT), get_to(m));
            },
            CAPTURE => {
                self.halfmove_clock = 0;
                self.history[self.game_ply].captured = self.board[get_to(m) as usize];
                self.move_piece(get_from(m), get_to(m));
            }
            _ => unreachable!()
        }

        self.history[self.game_ply].hash = self.hash;
        self.history[self.game_ply].halfmove_clock = self.halfmove_clock;
    }

    pub fn undo_move<const COLOR: Color>(&mut self, m: Move) {
        let flags: MoveFlags = get_flags(m);

        match flags {
            QUIET | DOUBLE_PUSH => {
                self.move_piece_quiet(get_to(m), get_from(m));
            },
            OO => {
                if COLOR == WHITE {
                    self.move_piece_quiet(G1, E1);
                    self.move_piece_quiet(F1, H1);
                } else {
                    self.move_piece_quiet(G8, E8);
                    self.move_piece_quiet(F8, H8);
                }
            },
            OOO => {
                if COLOR == WHITE {
                    self.move_piece_quiet(C1, E1);
                    self.move_piece_quiet(D1, A1);
                } else {
                    self.move_piece_quiet(C8, E8);
                    self.move_piece_quiet(D8, A8);
                }
            },
            EN_PASSANT => {
                self.move_piece_quiet(get_to(m), get_from(m));
                self.put_piece(create_piece(opposite::<COLOR>(), PAWN), (get_to(m) as Dir + relative_dir::<COLOR>(SOUTH)) as Square);
            },
            PQ_QUEEN | PQ_ROOK | PQ_BISHOP | PQ_KNIGHT => {
                self.remove_piece(get_to(m));
                self.put_piece(create_piece(COLOR, PAWN), get_from(m));
            },
            PC_QUEEN | PC_ROOK | PC_BISHOP | PC_KNIGHT => {
                self.remove_piece(get_to(m));
                self.put_piece(create_piece(COLOR, PAWN), get_from(m));
                self.put_piece(self.history[self.game_ply].captured, get_to(m));
            }
            CAPTURE => {
                self.move_piece_quiet(get_to(m), get_from(m));
                self.put_piece(self.history[self.game_ply].captured, get_to(m));
            }
            _ => unreachable!()
        }

        self.turn = self.turn ^ 1;
        self.game_ply -= 1;
        self.halfmove_clock = self.history[self.game_ply].halfmove_clock;
        self.result = None;
    }

    // todo: use const THEM: Color = US ^ 1;
    pub fn generate_moves<const US: Color, const THEM: Color>(&mut self) -> MoveList {
        let mut list = MoveList::new();
        
        // check for threefold
        let mut count = 1;
        for i in 0..self.game_ply {
            if self.history[i].hash == self.history[self.game_ply].hash {
                count += 1;
            }
        }

        if count >= 3 {
            self.result = Some(GameResult::ThreefoldRepetition);
            return list;
        }

        if self.halfmove_clock >= 50 {
            self.result = Some(GameResult::FiftyMoveRule);
            return list;
        }

        if self.bb_of(US, QUEEN) == 0 && self.bb_of(THEM, QUEEN) == 0 &&
        self.bb_of(US, ROOK) == 0 && self.bb_of(THEM, ROOK) == 0 &&
        self.bb_of(US, PAWN) == 0 && self.bb_of(THEM, PAWN) == 0 && 
        sparse_count_ones(self.bb_of(US, KNIGHT)) + sparse_count_ones(self.bb_of(US, BISHOP)) < 2 &&
        sparse_count_ones(self.bb_of(THEM, KNIGHT)) + sparse_count_ones(self.bb_of(THEM, BISHOP)) < 2 {
            self.result = Some(GameResult::InsufficientMaterial);
            return list;
        }

        let us_bb: Bitboard = self.all_pieces::<US>();
        let them_bb: Bitboard = self.all_pieces::<THEM>();

        let all = us_bb | them_bb;

        let our_king: Square = pop_lsb(&mut self.bb_of(US, KING));
        let their_king: Square = pop_lsb(&mut self.bb_of(THEM, KING));

        let our_diag_pieces: Bitboard = self.diagonal_pieces::<US>();
        let their_diag_pieces: Bitboard = self.diagonal_pieces::<THEM>();
        let our_orth_pieces: Bitboard = self.orthogonal_pieces::<US>();
        let their_orth_pieces: Bitboard = self.orthogonal_pieces::<THEM>();

        let mut b1: Bitboard;
        let mut b2: Bitboard;
        let mut b3: Bitboard;

        let mut danger: Bitboard = 0;

        danger |= all_pawn_attacks::<THEM>(self.bb_of(THEM, PAWN)) | attacks::<KING>(their_king, all);

        b1 = self.bb_of(THEM, KNIGHT);
        while b1 > 0 { danger |= attacks::<KNIGHT>(pop_lsb(&mut b1), all); }
        b1 = their_diag_pieces;
        while b1 > 0 { danger |= attacks::<BISHOP>(pop_lsb(&mut b1), all ^ SQUARE_BB[our_king as usize]); }
        b1 = their_orth_pieces;
        while b1 > 0 { danger |= attacks::<ROOK>(pop_lsb(&mut b1), all ^ SQUARE_BB[our_king as usize]); }

        b1 = attacks::<KING>(our_king, all) & !(us_bb | danger);
        make::<QUIET>(our_king, b1 & !them_bb, &mut list);
        make::<CAPTURE>(our_king, b1 & them_bb, &mut list);

        let capture_mask: Bitboard;
        let quiet_mask: Bitboard;

        let mut sq: Square;

        self.checkers = attacks::<KNIGHT>(our_king, them_bb) & self.bb_of(THEM, KNIGHT) |
            pawn_attacks::<US>(our_king) & self.bb_of(THEM, PAWN);

        let mut candidates: Bitboard = (attacks::<ROOK>(our_king, them_bb) & their_orth_pieces) |
            (attacks::<BISHOP>(our_king, them_bb) & their_diag_pieces);

            self.pinned = 0;
        while candidates > 0 {
            sq = pop_lsb(&mut candidates);
            b1 = SQUARES_BETWEEN[our_king as usize][sq as usize] & us_bb;

            if b1 == 0 { self.checkers ^= SQUARE_BB[sq as usize] }
            else if b1 & b1 - 1 == 0 { self.pinned ^= b1 }
        }

        let not_pinned: Bitboard = !self.pinned;

        match sparse_count_ones(self.checkers) {
            2 => {
                if list.size == 0 {
                    self.result = Some(GameResult::Checkmate(THEM));
                }
                return list
            },
            1 => {
                let checker: Square = self.checkers.trailing_zeros() as Square;

                match piece_type_of(self.board[checker as usize]) {
                    PAWN => {
                        // todo: use relative_dir::<US>(SOUTH)
                        if US == WHITE {
                            if self.checkers == shift_bb::<SOUTH>(
                                SQUARE_BB[self.history[self.game_ply].epsq as usize]
                            ) {
                                b1 = pawn_attacks::<THEM>(self.history[self.game_ply].epsq) & self.bb_of(US, PAWN) & not_pinned;
                                while b1 > 0 {
                                    list.push(create_move(pop_lsb(&mut b1), self.history[self.game_ply].epsq, EN_PASSANT));
                                }
                            }
                        } else {
                            if self.checkers == shift_bb::<NORTH>(
                                SQUARE_BB[self.history[self.game_ply].epsq as usize]
                            ) {
                                b1 = pawn_attacks::<THEM>(self.history[self.game_ply].epsq) & self.bb_of(US, PAWN) & not_pinned;
                                while b1 > 0 {
                                    list.push(create_move(pop_lsb(&mut b1), self.history[self.game_ply].epsq, EN_PASSANT));
                                }
                            }
                        }
                        b1 = self.attackers_from::<US>(checker, all) & not_pinned;
                        while b1 > 0 {
                            list.push(create_move(pop_lsb(&mut b1), checker, CAPTURE));
                        }

                        if list.size == 0 {
                            self.result = Some(GameResult::Checkmate(THEM));
                        }
                        return list;
                    }
                    KNIGHT => {
                        b1 = self.attackers_from::<US>(checker, all) & not_pinned;
                        while b1 > 0 {
                            list.push(create_move(pop_lsb(&mut b1), checker, CAPTURE));
                        }

                        if list.size == 0 {
                            self.result = Some(GameResult::Checkmate(THEM));
                        }
                        return list;
                    }
                    _ => {
                        capture_mask = self.checkers;

                        quiet_mask = SQUARES_BETWEEN[our_king as usize][checker as usize];
                    }
                };
            },
            _ => {
                capture_mask = them_bb;

                quiet_mask = !all;

                if self.history[self.game_ply].epsq != SQUARE_NONE {
                    b2 = pawn_attacks::<THEM>(self.history[self.game_ply].epsq) & self.bb_of(US, PAWN);
                    b1 = b2 & not_pinned;

                    // todo: use relative_dir::<US>(SOUTH)
                    let ep_bb = if US == WHITE {
                        shift_bb::<SOUTH>(SQUARE_BB[self.history[self.game_ply].epsq as usize])
                    } else {
                        shift_bb::<NORTH>(SQUARE_BB[self.history[self.game_ply].epsq as usize])
                    };
                    while b1 > 0 {
                        sq = pop_lsb(&mut b1);

                        if sliding_attacks(
                            our_king,
                            all ^ SQUARE_BB[sq as usize] ^ ep_bb,
                            MASK_RANK[rank_of(our_king) as usize]
                        ) & their_orth_pieces == 0 {
                            list.push(create_move(sq, self.history[self.game_ply].epsq, EN_PASSANT));
                        }
                    }

                    b1 = b2 & self.pinned & LINE_BETWEEN[self.history[self.game_ply].epsq as usize][our_king as usize];
                    if b1 > 0 {
                        list.push(create_move(pop_lsb(&mut b1), self.history[self.game_ply].epsq, EN_PASSANT));
                    }
                }

                if (self.history[self.game_ply].entry & oo_mask::<US>()) |
                ((all | danger) & oo_blockers_mask::<US>()) == 0 {
                    list.push(if US == WHITE {
                        create_move(E1, G1, OO)
                    } else {
                        create_move(E8, G8, OO)
                    });
                }
                if (self.history[self.game_ply].entry & ooo_mask::<US>()) |
                ((all | (danger & !ooo_ignore_danger::<US>())) & ooo_blockers_mask::<US>()) == 0 {
                    list.push(if US == WHITE {
                        create_move(E1, C1, OOO)
                    } else {
                        create_move(E8, C8, OOO)
                    });
                }

                b1 = !(not_pinned | self.bb_of(US, KNIGHT));

                while b1 > 0 {
                    sq = pop_lsb(&mut b1);
                    b2 = get_attacks(piece_type_of(self.board[sq as usize]), sq, all) &
                        LINE_BETWEEN[our_king as usize][sq as usize];
                    make::<QUIET>(sq, b2 & quiet_mask, &mut list);
                    make::<CAPTURE>(sq, b2 & capture_mask, &mut list);
                }

                b1 = !not_pinned & self.bb_of(US, PAWN);

                while b1 > 0 {
                    sq = pop_lsb(&mut b1);

                    if rank_of(sq) == relative_rank::<US>(RANK_7) {
                        b2 = pawn_attacks::<US>(sq) & capture_mask & LINE_BETWEEN[our_king as usize][sq as usize];
                        make::<PROMOTION_CAPTURES>(sq, b2, &mut list);
                    } else {
                        b2 = pawn_attacks::<US>(sq) & capture_mask & LINE_BETWEEN[our_king as usize][sq as usize];
                        make::<CAPTURE>(sq, b2, &mut list);

                        // todo: use relative_dir::<US>
                        if US == WHITE {
                            b2 = shift_bb::<NORTH>(SQUARE_BB[sq as usize]) & !all & LINE_BETWEEN[our_king as usize][sq as usize];
                            b3 = shift_bb::<NORTH>(b2 & MASK_RANK[relative_rank::<US>(RANK_3) as usize]) & !all & LINE_BETWEEN[our_king as usize][sq as usize];

                            make::<QUIET>(sq, b2, &mut list);
                            make::<DOUBLE_PUSH>(sq, b3, &mut list);
                        } else {
                            b2 = shift_bb::<SOUTH>(SQUARE_BB[sq as usize]) & !all & LINE_BETWEEN[our_king as usize][sq as usize];
                            b3 = shift_bb::<SOUTH>(b2 & MASK_RANK[relative_rank::<US>(RANK_3) as usize]) & !all & LINE_BETWEEN[our_king as usize][sq as usize];

                            make::<QUIET>(sq, b2, &mut list);
                            make::<DOUBLE_PUSH>(sq, b3, &mut list);
                        }
                    }
                }
            }
        };

        b1 = self.bb_of(US, KNIGHT) & not_pinned;

        while b1 > 0 {
            sq = pop_lsb(&mut b1);
            b2 = attacks::<KNIGHT>(sq, all);

            make::<QUIET>(sq, b2 & quiet_mask, &mut list);
            make::<CAPTURE>(sq, b2 & capture_mask, &mut list);
        }

        b1 = our_diag_pieces & not_pinned;
        while b1 > 0 {
            sq = pop_lsb(&mut b1);
            b2 = attacks::<BISHOP>(sq, all);

            make::<QUIET>(sq, b2 & quiet_mask, &mut list);
            make::<CAPTURE>(sq, b2 & capture_mask, &mut list);
        }

        b1 = our_orth_pieces & not_pinned;
        while b1 > 0 {
            sq = pop_lsb(&mut b1);
            b2 = attacks::<ROOK>(sq, all);

            make::<QUIET>(sq, b2 & quiet_mask, &mut list);
            make::<CAPTURE>(sq, b2 & capture_mask, &mut list);
        }

        b1 = self.bb_of(US, PAWN) & not_pinned & !MASK_RANK[relative_rank::<US>(RANK_7) as usize];

        // todo: use relative_dir::<US>(NORTH)
        if US == WHITE {
            b2 = shift_bb::<NORTH>(b1) & !all;
            b3 = shift_bb::<NORTH>(b2 & MASK_RANK[relative_rank::<US>(RANK_3) as usize]) & quiet_mask;
        } else {
            b2 = shift_bb::<SOUTH>(b1) & !all;
            b3 = shift_bb::<SOUTH>(b2 & MASK_RANK[relative_rank::<US>(RANK_3) as usize]) & quiet_mask;
        }

        b2 &= quiet_mask;

        while b2 > 0 {
            sq = pop_lsb(&mut b2);
            list.push(create_move((sq as Dir - relative_dir::<US>(NORTH)) as Square, sq, QUIET));
        }

        while b3 > 0 {
            sq = pop_lsb(&mut b3);
            list.push(create_move((sq as Dir - relative_dir::<US>(NORTH_NORTH)) as Square, sq, DOUBLE_PUSH));
        }

        // todo: use relative_dir::<US>(NORTH)
        if US == WHITE {
            b2 = shift_bb::<NORTH_WEST>(b1) & capture_mask;
            b3 = shift_bb::<NORTH_EAST>(b1) & capture_mask;
        } else {
            b2 = shift_bb::<SOUTH_EAST>(b1) & capture_mask;
            b3 = shift_bb::<SOUTH_WEST>(b1) & capture_mask;
        }

        while b2 > 0 {
            sq = pop_lsb(&mut b2);
            list.push(create_move((sq as Dir - relative_dir::<US>(NORTH_WEST)) as Square, sq, CAPTURE));
        }

        while b3 > 0 {
            sq = pop_lsb(&mut b3);
            list.push(create_move((sq as Dir - relative_dir::<US>(NORTH_EAST)) as Square, sq, CAPTURE));
        }

        b1 = self.bb_of(US, PAWN) & not_pinned & MASK_RANK[relative_rank::<US>(RANK_7) as usize];
        if b1 > 0 {
            // todo: use relative_dir::<US>(NORTH)
            if US == WHITE {
                b2 = shift_bb::<NORTH>(b1) & quiet_mask;
            } else {
                b2 = shift_bb::<SOUTH>(b1) & quiet_mask;
            }
            
            while b2 > 0 {
                sq = pop_lsb(&mut b2);
                list.push(create_move((sq as Dir - relative_dir::<US>(NORTH)) as Square, sq, PQ_QUEEN));
                list.push(create_move((sq as Dir - relative_dir::<US>(NORTH)) as Square, sq, PQ_ROOK));
                list.push(create_move((sq as Dir - relative_dir::<US>(NORTH)) as Square, sq, PQ_BISHOP));
                list.push(create_move((sq as Dir - relative_dir::<US>(NORTH)) as Square, sq, PQ_KNIGHT));
            }

            if US == WHITE {
                b2 = shift_bb::<NORTH_WEST>(b1) & capture_mask;
                b3 = shift_bb::<NORTH_EAST>(b1) & capture_mask;
            } else {
                b2 = shift_bb::<SOUTH_EAST>(b1) & capture_mask;
                b3 = shift_bb::<SOUTH_WEST>(b1) & capture_mask;
            }

            while b2 > 0 {
                sq = pop_lsb(&mut b2);
                list.push(create_move((sq as Dir - relative_dir::<US>(NORTH_WEST)) as Square, sq, PC_QUEEN));
                list.push(create_move((sq as Dir - relative_dir::<US>(NORTH_WEST)) as Square, sq, PC_ROOK));
                list.push(create_move((sq as Dir - relative_dir::<US>(NORTH_WEST)) as Square, sq, PC_BISHOP));
                list.push(create_move((sq as Dir - relative_dir::<US>(NORTH_WEST)) as Square, sq, PC_KNIGHT));
            }
            while b3 > 0 {
                sq = pop_lsb(&mut b3);
                list.push(create_move((sq as Dir - relative_dir::<US>(NORTH_EAST)) as Square, sq, PC_QUEEN));
                list.push(create_move((sq as Dir - relative_dir::<US>(NORTH_EAST)) as Square, sq, PC_ROOK));
                list.push(create_move((sq as Dir - relative_dir::<US>(NORTH_EAST)) as Square, sq, PC_BISHOP));
                list.push(create_move((sq as Dir - relative_dir::<US>(NORTH_EAST)) as Square, sq, PC_KNIGHT));
            }
        }

        self.in_check = sparse_count_ones(self.checkers) != 0;
        if list.size == 0 {
            if self.in_check {
                self.result = Some(GameResult::Checkmate(THEM));
            } else {
                self.result = Some(GameResult::Stalemate);
            }
        }

        list
    }

    pub fn print(&self, highlighted_squares: Bitboard) {
        const TOP_LINE: &str = "   ";
        const MID_LINE: &str = "   ";
        const BOT_LINE: &str = "   \n     a   b   c   d   e   f   g   h";

        println!("{}", TOP_LINE);
        for i in 0..8 {
            if i > 0 {
                println!("{}", MID_LINE);
            }
            print!(" {} ", (7 - i) + 1);
            for j in 0..8 {
                let piece = PIECE_STR[self.board[(7 - i) * 8 + j] as usize];

                if highlighted_squares & (1 <<  ((7 - i) * 8 + j)) == 0 {
                    print!(" {} ", piece);
                } else {
                    print!("-{}-", piece);
                }
            }
            println!();
        }
        println!("{}", BOT_LINE);
    }
}

impl PartialEq for Position {
    fn eq(&self, other: &Self) -> bool {
        self.hash == other.hash
    }

    fn ne(&self, other: &Self) -> bool {
        !self.eq(other)
    }
}

impl std::fmt::Display for Position {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        const TOP_LINE: &str = "   ";
        const MID_LINE: &str = "   ";
        const BOT_LINE: &str = "   \n     a   b   c   d   e   f   g   h";

        writeln!(f, "{}", TOP_LINE)?;
        for i in 0..8 {
            if i > 0 {
                writeln!(f, "{}", MID_LINE)?;
            }
            write!(f, " {} ", (7 - i) + 1)?;
            for j in 0..8 {
                write!(f, " {} ", PIECE_STR[self.board[(7 - i) * 8 + j] as usize])?;
            }
            writeln!(f)?;
        }
        writeln!(f, "{}", BOT_LINE)?;

        writeln!(f, "FEN: {}", self.fen())?;
        writeln!(f, "Hash: 0x{:x}", self.hash)
    }
}